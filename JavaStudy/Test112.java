/*===================================
클래스 고급
-상속
================================*/

//super

//static 으로 선언되지 않은 메소드에서 사용되며
//현재 클래스가 상속받은 상위 클래스의 객체를 가리킨다.
//super는 상위 클래스의 생성자를 호출하거나
//상위 클래스의 멤버 변수 또는 메소드를 호출할 때 사용할 수 있다.

//하위 클래스의 생성자에서 상위 클래스의 생성자를 호출할 때에는
//하위 클래스의 생성자 정의 구문에서 맨 처음에만 위치할 수 있따.

//생성자와 클래스 상속간의 관계

//하위 클래스는 상위 클래스의 멤버를 상속받지만,
//생성자는 상속 대상에서 제외된다.
//그리고 하위클래스의 생성자가 호출될 때
//자동으로 상위 클래스의 생성자를 호출하게 된다.
//이때,상위 클래스의 생성자는
//인수가 없는 생성자(default 생성자 형태)가 호출된다.

//상위 클래스 및 하위클래스(즉 상속관계에 있는 클래스)를 설계하는 과정에서
//상위 클래스의 생성자를 정의하지(작성하지) 않거나
//인수가 없는 생성자만을 정의한(작성한) 경우
//명시적으로 하위 클래스에서 상위 클래스의 생성자를 호출하지 않아도
//아무런 문제가 발생하지 않지만,
//상위 클래스에 인자가 있는 생성자만 존재하는 경우
//주의해야한다.

//예를 들어 다음에서...
/* class A_class
{
	A_class(int n)
	{
	}
}

   class B_class extends A_class
   {
	   B_class()
	   {
		   super();
	   }
   }

*/
/*
하위 클래스인 B_class 의 생성자에서
 명시적으로 A_class의 생성자를 호출하지 않으면
자동으로 인자 없는 생성자를 호출한다.
하지만 A_class에는 인자가 있는 생성자만 존재하므로
에러가 발생한다. 따라서,B_class 생성자의 선두에
다음처럼 명시적으로 상위 클래스의 생성자 호출 구문을 
작성해야 한다.

class A_class
{
	A_class(int n)
	{
	}
}

class B_class extends A_class
{
	B_class()
{
		super(10);
}

상속시 주의할 사항

	상위 클래스에서 선언된 멤버 변수의 이름과
 하위 클래스에서 선언된 멤버 변수의 이름이 같다면 상위 클래스의 멤버 변수는 무시된다.
이때 상위 클래스의 멤버 변수를 사용하기 위해서는
 super 키워드를 사용한다.

동일한 이름의 멤버 변수나 동일한 이름의 메소드가
한 클래스 안에 선언되거나 정의되는 경우 기본적으로 에러 발생한다.
단 메소드의 경우에는 매개변수의 갯수나 타입이 다른 경우
에러 발생하지 않고 이들을 서로 다른 메소드로 취급하게 된다.

*/

//Circle112 와 Rect112 클래스의 부모 클래스
class SuperTest112 
{
	protected double area;
	private String title; //이건 자식클래스에게도 상속안해주겠다 라는 private

	public SuperTest112()
	{
		System.out.println("SuperTest112..인자없는 생성자");
	}

	public SuperTest112(String title)
	{
		this.title = title;
		System.out.println("SuperTest112... 문자열을 인자로 받는 생성자");
	}

	public void write()
	{
		System.out.println(title+"-"+area);
	}
}

class Rect112 extends SuperTest112 //자식클래스 (단일 상속)
{
	private int w,h;
	public Rect112()
	{
		super();
	}

	public void calc(int w, int h)
	{
		this.w = w;
		this.h = h;
		area = (double)this.w + this.h;
		write();
	}
   @Override //일부러 오버라이드한거야!! 1.잘못쓴거아니다. 2.그러니까 뭔가 틀렸거나 이상하면 알려줘라, 이를 어노테이션(annotation) = metadata라고하며 이는 직접 수식에 포함되는것이 아닌
	public void write()																									//단순히 보조하는 수단  즉 사진을 보조하는 인스타의 해시태그 같은것
	{																													//즉 게시물이나 그런 디테일에 영향을 끼치는게 아닌 이것이 그것이라는 의미를 가지는 정도
   		System.out.println("w : "+w+",h : " + h);																		//JDK1.5버전에서 나온다.
		System.out.println("사각형 - " + area);
	}//원래는 이 메소드는 메소드 오버로딩(중복정의)의 규칙에 어긋나서 안되지만
	//상속에한에서
	//메소드 오버라이딩(재정의) (오직 상속을 위해서만 존재한다.)

	//상위 클래스를 상속받은 하위 클래스에서
	//상위 클래스에서 정의된 메소드를 다시 정의하는 것으로(재정의)
	//객체 지향 프로그래밍의 특징인 다형성을 나타낸다.
	//재정의(Overriding)는 반드시 상속 관계에 있어야 하며
	//메소드 이름, 리턴타입,매개변수의 갯수나 타입이
	//모두 완전히 일치해야 한다.
	//단 물려받은 메소드의 접근제어 지시자는 반드시 써야한다.
	//다만!! protected -> public 으로 허용범위를 넓힐수는있으나
	//protected-> private or default와 같이 허용범위를 좁히는것은 불가능하다.
}

class Circle112 extends SuperTest112 //자식클래스 (단일 상속)
{

	public Circle112(String title)
	{
		super(title);
	}

	public void calc(int r)
	{
		area = r*r*3.141592;
		write();

	}
}
public class Test112
{
	public static void main(String[] args)
	{
		Rect112 ob1 = new Rect112();
		//SuperTest112..인자없는 생성자 //사용자 정의 생성자가 있는데? 사용자 정의 생성자를 만들어도 자동으로 super();가 자동으로 들어간다.
		
		//Circle112 ob2 = new Circle112(); //사용자 정의 생성자가 존재하기에 디폴트 생성자는 만들어지지 않고 매개변수로 String타입을 필요로하기 때문에
		//에러발생 (컴파일 에러)
		//현재 circle112 클래스에는
		//매개변수를 필요로하는 사용자 정의 생성자가 만들어져 있으며
		//이로인해 default 생성자가 자동으로 삽입되지 않는다.


		ob1.calc(3,4); //물려받은것이 아닌 본인의 클래스에서 오버라이딩한 write를 호출한다.
	
	/* 상속이란 것은 물려받는 클래스에 적용되는 것이다. 즉 물려받는놈이 주체
==================================================================
상위 클래스  | 하위 클래스   | 결과
-------------------------------------------------------------------
생성자를     |생성자정의안함    | 가능 상위클래스 디폴트 생성 자식클래스 디폴트생성 그 안에 super();생성됨
정의하지     |인수가 없는 생성자| 가능 상위클래스 디폴트 생성 자식클래스 사용자정의생성 그 안에 super();생성됨//부모클래스의 생성자 호출구문 자동 삽입
않음         |인수가 있는 생성자| 가능하다.
-------------------------------------------------------------------
인수가       |생성자정의안함    |->가능
없는         |인수가 없는 생성자|->가능  왜냐면 하위 클래스의 디폴트 생성자가 매개변수가 없는타입이므로 위와 결과가 같다.
생성자만 정의|인수가 있는 생성자|->가능   
-------------------------------------------------------------------
인수가       |생성자정의안함    |->불가능
있는         |인수가 없는 생성자|->만약 하위에서 생성자안에서 인수있는 부모의 생성자를 호출시 가능 ///아니면 부모의 디폴트를 호출할 것이므로 안됨
생성자만 정의|인수가 있는 생성자|->만약 하위에서 생성자안에서 인수있는 부모의 생성자를 호출시 가능 ///아니면 부모의 디폴트를 호출할 것이므로 안됨
==================================================================
부모클래스에서 생성자를 정의한 순간 부모클래스의 디폴트 생성자는 존재하지 않는다. 

*/
	
	}

}

