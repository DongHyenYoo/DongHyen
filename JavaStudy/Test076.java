/*===================================
클래스와 인스턴스
-생성자(Constructor)
================================*/

public class Test076
{
	int x;
	//변수의 이름이나 메소드의 이름은 식별자의 역할을 많이한다.
	//즉 한번 선언한 변수는 어떤 자료형이든 뭐든 같은 이름의 변수로 다시 선언할수 없다. 형변환을 하면 또 문제가 되므로
	//x가 존재하는 영역안에서는 안된다.

	//단 메소드의 경우 이름이 같더라도 매개변수의 타입 개수등의 차이로 구별이 가능하다면 같은 이름을 가질수 있다.
	//메소드 오버로딩이라고 부른다.

	//생성자도 본질은 메소드기에 메소드 오버로딩이 가능하다.
	/* 생성자의 이름은 항상 클래스의 이름과 동일하고
	   필요할 경우 인수를 받아들이는 것도 가능
	   같은 이름의 메소드를 정의하는 중복정의가 가능하나
	   리턴값은 가질수 없다.


	   생성자는 다른 일반 메소드처럼 호출될 수 없고
	   new 연산자를 이용하여 객체를 생성하기 위해 호출되며
	   각 클래스의 인스턴스인 객체를 생성한후에
	   생성된 객체의 멤버를 초기화 시키는 작업을 수행하게된다.
	   */


	Test076()
	{
		//생성자 내부에서 다른 생성자를 호출하는 것은 가능하다.
		//단 조건이 붙는다. 생성자 내부에서 가장 먼저 실행되어야 한다.********
		
		this(100);

		x=10;

		System.out.println("Test076이 가지고 있는 생성자값 : "+this.x);
		System.out.println("Test076이 가지고 있는 생성자값 : "+x);
	}
	
	Test076(int x) //왜 int num으로 하는것보다 int x보다 나은가?
	               //넘겨받은 매개변수로 x를 초기화 시키려고하는 생성자의 매개변수이다.
				   //즉 x를 초기화 할것이므로 같은 변수이름으로 일반적으로 써놓는다.
	{
		//x = x;  //전역변수 x 를 매개변수x로 초기화
				// 아까 x가 존재하는 영역에서는 새로 x를 선언하면 안된다라고했는데
				// 다만 지역변수 x와 전역변수 x를 식별할수 있게만들면 된다.
				// 그리고 이것의 의미는 둘다 지역변수 x이기에 
				// this 키워드를 사용한다.
				//왜냐면 Test076.x  이 구문도 이미 선점했다.그러므로
				//this.x = x; 이렇게 써야한다.
		
		
		this.x = x; // 이 this가 포함되어 있는 클래스를 찾아라 
		            // 즉 이 this는 Test076을 대신하는것과 같다.
					//매개변수가 num이라면	this.x = num 이렇게 해도된다.


		System.out.println("인자가 하나인 생성자");
		System.out.println(this.x); //전역변수 x 출력
		System.out.println(x); //매개변수 x 출력
	}

	//생성자가 생성자를 호출할 수 있을까?
	//사과장수(int 가격)
	// 사과장수(400,20,1000); 이렇게 안될까?
	//사과장수(int 지갑,int머니,int개수)
	//된다. 다만 생성자는 생성자 내부에서 가장 먼저 실행되어야한다.
	//다만 이 이유는 다른생성자를 호출한 생성자에서 진짜로 자기가 하고싶은 일을
	//마지막에 해서 적용하려고한다

	//this(100);처럼 호출해야한다. 매개변수가 하나고 int형인 경우 클래스내에서 
	//클래스와 같은 이름의 메소드를 찾아 그중에 매개변수가 int형으로 한개만 받는 생성자를 호출하는 것이다.






	public static void main(String[] args)
	{

		Test076 ob1 = new Test076();
		Test076 ob2 = new Test076(100);

		System.out.println();
		System.out.println("main에서의 ob1.x : "+ ob1.x);
		System.out.println("main에서의 ob1.x : "+ ob2.x);



}
}